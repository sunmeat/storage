1.Что такое .Net
Платформа Microsoft .NET Framework — это технология, которая поддерживает создание и выполнение приложений различных типов. Главной идеей разработки .NET Framework было стремление сделать кроссплатформенную виртуальную машину для выполнения одного и того же кода в различных ОС, но со временем Microsoft ограничилась поддержкой только своих операционных систем Windows. Считается, что платформа .NET Framework явилась ответом компании Microsoft на набравшую к тому времени большую популярность платформу Java. Платформа .NET — это среда, которую видит код в процессе исполнения. Это означает, что .NET занимается исполнением кода: запускает его, даёт ему соответствующие права, выделяет память для хранения данных, помогает с освобождением памяти и ресурсов, которые больше не требуются, и тд. Код, сгенерированный для .NET, может быть проверен на безопасность. Это гарантирует, что приложение не может навредить пользователю или нарушить функционирование операционной системы. Вероятно, самым большим достижением .NET остаётся межъязыковое взаимодействие (language interoperability). Впервые в истории программирования появляется единая модель, позволяющая на равных пользоваться различными языками для создания приложений. Так как MSIL не зависит от исходного языка программирования или от целевой платформы, в рамках .NET становится возможным развивать новые программы на	базе старых программ.
MSIL - это язык, на котором должен быть написан код, загружаемый и запускаемый средой исполнения .NET. При компиляции управляемого кода компилятор генерирует код на промежуточном языке, a CLR выполняет заключительную стадию компиляции непосредственно перед исполнением кода. Язык IL разработан таким образом, чтобы обеспечить быструю компиляцию в машинный код, но в то же время он поддерживает все особенности .NET. 
Сборки 
Сборка — это логическая единица, которая содержит компилированный код, предназначенный для .NET. С этой точки зрения сборка аналогична DLL и исполняемому файлу или файлу, содержащему компоненты СОМ. Сборка полностью описывает себя и является логической, а не физической единицей, так как может располагаться более чем в одном файле. Если сборка хранится в нескольких файлах, то существует один главный файл, содержащий точку входа и информацию о других файлах сборки. 
Заметим, что для исполняемого кода и кода библиотеки используется одинаковая структура сборки. Единственное отличие заключается в том, что исполняемая сборка содержит точку входа основной программы, а библиотечная сборка — нет. 
Метаданные и манифесты 
Важной характеристикой сборок является то, что они содержат метаданные, описывающие типы и методы, определенные в соответствующем коде. Сборка содержит также метаданные, которые описывают саму сборку. Метаданные сборки, хранящиеся в области, известной как манифест, позволяют проверить версию сборки, ее целостность и ряд других сведений. 
Тот факт, что сборка содержит метаданные о программе, означает, что программы и сборки, которые вызывают код этой сборки, не должны обращаться к реестру или иному источнику данных для выяснения того, как использовать сборку. Это значительный прорыв по сравнению со старой технологией СОМ, когда из реестра необходимо было получать GUID компонентов и их интерфейсы, а в некоторых случаях детали методов и свойств приходилось читать из библиотек типов. 
То, что данные были разбросаны по двум, а то и трем различным местам, могло привести к рассинхронизации данных и соответственно к невозможности использования библиотеки другим кодом. При применении сборок отсутствует риск нарушения синхронизации, так как все метаданные хранятся вместе с исполняемыми инструкциями программы. Отметим, что хотя сборки могут храниться в нескольких файлах, это все равно не создает проблемы рассинхронизации данных. Дело в том, что файл, содержащий точку входа основной программы, имеет также информацию и хэш, сформированный на основе содержимого других файлов. Если один из файлов будет удален, заменен или каким-либо образом модифицирован, это будет сразу же обнаружено, и сборка не станет загружаться. 
CLR (Common Language Runtime), предоставляющая среду, в которой выполняются программы. Главная её роль заключается в том, чтобы обнаруживать и загружать типы .NET и производить управление ими в соответствии с полученными командами. CLR включает в себя виртуальную машину, во многих отношениях аналогичную виртуальной машине Java. Среда исполнения активизирует объекты, производит проверку безопасности, размещает объекты в памяти, выполняет их, а также запускает сборщик мусора. Над уровнем CLR находится набор базовых классов платформы, над ним расположены слой классов данных и XML, а также слой классов для создания Web-служб (Web Services), Web- и Windows-приложений (Web Forms и Windows Forms). Собранные воедино, эти классы известны под общим именем FCL (Framework Class Library). Это одна из самых больших библиотек классов в истории программирования. Она открывает доступ к системным функциям, включая и те, что прежде были доступны только через API Windows, а также к прикладным функциям для Web-разработки (ASP.NET), доступа к данным (ADO.NET), обеспечения безопасности и удаленного управления. Имея в своём составе более 4000 классов, библиотека FCL способствует быстрой разработке настольных, клиент-серверных и других приложений и Web-служб. Microsoft .NET поддерживает не только языковую независимость, но и языковую интеграцию. Это означает, что разработчик может наследоваться от классов, обрабатывать исключения и использовать преимущества полиморфизма при одновременной работе с несколькими языками. Платформа .NET Framework предоставляет такую возможность с помощью спецификации CTS (Common Type System — общая система типов), которая полностью описывает все типы данных, поддерживаемые средой выполнения, определяет, как одни типы данных могут взаимодействовать с другими и как они будут представлены в формате метаданных .NET. Важно понимать, что не во всех языках программирования .NET обязательно должны поддерживаться все типы данных, которые определены в CTS. Спецификация CLS (Common Language Specification — общая языковая спецификация) устанавливает основные правила, определяющие законы, которым должны следовать все языки: ключевые слова, типы, примитивные типы, перегрузки методов и т. п. Спецификация CLS определяет минимальные требования, предъявляемые к языку платформы .NET. Компиляторы, удовлетворяющие этой спецификации, создают объекты, способные взаимодействовать друг с другом. Любой язык, соответствующий требованиям CLS, может использовать все возможности библиотеки FCL. CLS позволяет и разработчикам, и поставщикам, и производителям программного обеспечения не выходить за пределы общего набора правил для 	языков, компиляторов и типов данных. Common Language Runtime (англ. CLR — общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в который компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.
В отличие от переносимых виртуальных машин Java, абстрагирующихся от нижележащих операционных систем, CLR позиционируется как не "виртуализированная" платформа, тесно связанная с операционной системой Microsoft Windows. Common Type System (cтандартная система типов) — часть .NET Framework, формальная спецификация, определяющая, как какой-либо тип (класс, интерфейс, структура, встроенный тип данных) должен быть определён для его правильного выполнения средой .NET. Кроме того, данный стандарт определяет, как типы и специальные значения типов представлены в компьютерной памяти. Целью разработки CTS было обеспечение возможности программам, написанным на различных языках программирования, легко обмениваться информацией. Как это принято в языках программирования, тип может быть описан как определение набора допустимых значений (например, «все целые от 0 до 10») и допустимых операций над этими значениями (например, сложение и вычитание). Чтобы обеспечить полное взаимодействие между объектами вне зависимости от их языка, объекты должны предоставлять вызывающим объектам функции, общие для всех языков. Этот общий набор компонентов определяется общеязыковой спецификацией (Common Language Specification) — рядом правил, который применяется к создаваемым сборкам. CLS – это минимальный набор стандартов, который гарантирует, что доступ к коду может быть осуществлён из любого языка. Base Class Library, сокращённо BCL — стандартная библиотека классов платформы .NET. Программы, написанные на любом из языков, поддерживающих платформу .NET, могут пользоваться классами и методами BCL — создавать объекты классов, вызывать их методы, наследовать необходимые классы BCL и тд.
Не все языки, поддерживающие платформу .NET, предоставляют или обязаны предоставлять одинаково полный доступ ко всем классам и всем возможностям BCL — это зависит от особенностей реализации конкретного компилятора и языка. Библиотека базового класса (BCL) буквально такова, база. Он содержит основные, фундаментальные типы, такие как System.String и System.DateTime.
Библиотека классов классов (FCL) - это более широкая библиотека, которая содержит всю совокупность: ASP.NET, WinForms, стек XML, ADO.NET и другие. Вы можете сказать, что FCL включает BCL. 
CLI (Common Language Infrastructure) — спецификация общеязыковой инфраструктуры. Наиболее известными реализациями этого стандарта являются Microsoft .NET Framework, Mono, DotGNU Portable.NET. Спецификация CLI определяет, в частности, архитектуру исполнительной системы .NET — CLR и сервисы, предоставляемые CLR выполняемым программам, классы, предоставляемые библиотекой BCL, синтаксис и мнемонику общего промежуточного языка (IL).
Компиляция Just-In-Time (JIT). Этот термин обозначает процесс выполнения заключительной стадии компиляции с промежуточного языка в машинный код. Название определяется тем, что части кода компилируются по мере необходимости. 
MSIL-код содержит инструкции, независимые ни от языка программирования, ни от ОС, ни от процессора. Важно понимать, что программа на языке MSIL – это по-прежнему ООП-код. Среда CLR исполняет управляемый ООП-код, оперируя объектами, и в этом заключается идея виртуального процессора. В то время как среда исполнения неуправляемого кода выполняет низкоуровневые инструкции процедурного кода. Это главное отличие среды исполнения CLR от среды исполнения неуправляемого кода!
Сборка — это логическая единица, которая содержит компилированный код, предназначенный для .NET. С этой точки зрения сборка аналогична DLL и исполняемому файлу. Сборка полностью описывает себя и является логической, а не физической единицей, так как может располагаться более чем в одном файле. Если сборка хранится в нескольких файлах, то существует один главный файл, содержащий точку входа и информацию о других файлах сборки. 
Важной характеристикой сборок является то, что они содержат метаданные, описывающие типы и методы, определенные в соответствующем коде. Сборка содержит также метаданные, которые описывают саму сборку. Метаданные сборки, хранящиеся в области, известной как манифест, позволяют проверить версию сборки, её целостность и ряд других сведений. Mанифест – это сведения о самой сборке (номер версии сборки, языковые настройки, список других внешних сборок, необходимых для нормальной работы программы и тд).
Ссылочные типы и значимые типы
Основные отличия ссылочных типов и типов по значению:
операция присваивания
если применить данную операцию к ссылочным типам то скопируется адрес объекта, но не сам объект, две ссылки будут указывать на один объект.
Если применить к значимому типу, то произойдет копирования значения из одной переменной в другую
операция сравнения
ссылочные типы — будут сравниваться адреса объектов, а не сами объекты
значимые типы — будет сравнения значений переменных
Упаковка и распаковка
Упаковка представляет собой процесс преобразования типа значения в тип object или в любой другой тип интерфейса, реализуемый этим типом значения. Когда тип значения упаковывается общеязыковой средой выполнения (CLR), он инкапсулирует значение внутри экземпляра System.Object и сохраняет его в управляемой куче. Операция распаковки извлекает тип значения из объекта. Упаковка является неявной; распаковка является явной. Понятия упаковки и распаковки лежат в основе единой системы типов C#, в которой значение любого типа можно рассматривать как объект. 
Упаковка используется для хранения типов значений в куче со сбором мусора. Упаковка представляет собой неявное преобразование типа значения в тип object или в любой другой тип интерфейса, реализуемый этим типом значения. При упаковке типа значения в куче выделяется экземпляр объекта и выполняется копирование значения в этот новый объект. 
Распаковка является явным преобразованием из типа object в тип значения или из типа интерфейса в тип значения, реализующего этот интерфейс. Операция распаковки состоит из следующих действий:
●проверка экземпляра объекта на то, что он является упакованным значением заданного типа значения;
●копирование значения из экземпляра в переменную типа значения.
●
Foreach
https://habr.com/ru/post/209914/
еще одним механизмом циклов, предлагаемых С#, является цикл foreach. Если другие циклы применялись в более ранних версиях С и C++, то оператор foreach новый. 
Цикл foreach позволяет производить итерацию по каждому объекту в контейнерном классе, имлементирующий метод GetEnumerator. 
Утиная типизация - определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов.
Свойства - Кроме обычных методов в языке C# предусмотрены специальные методы доступа, которые называют свойства. Они обеспечивают простой доступ к полям классов и структур, узнать их значение или выполнить их установку.  Стандартное определение свойства содержит блоки get и set. В блоке get мы возвращаем значение поля, а в блоке set устанавливаем. Параметр value представляет передаваемое значение. Возможно, может возникнуть вопрос, зачем нужны свойства, если мы можем в данной ситуации обходиться обычными полями класса? Но свойства позволяют вложить дополнительную логику, которая может быть необходима, например, при присвоении переменной класса какого-либо значения. Мы можем применять модификаторы доступа не только ко всему свойству, но и к отдельным блокам - либо get, либо set
Свойства управляют доступом к полям класса. Однако что, если у нас с десяток и более полей, то определять каждое поле и писать для него однотипное свойство было бы утомительно. Поэтому в фреймворк .NET были добавлены автоматические свойства. Они имеют сокращенное объявление:
1
2
3
4
5
6
7
8
9
10
11classPerson
{
    publicstringName { get; set; }
    publicintAge { get; set; }
         
    publicPerson(stringname, intage)
    {
Name = name;
        Age = age;
    }
} 
Статический конструктор
Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты:
●Статические конструкторы не должны иметь модификатор доступа и не принимают параметров
●Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this для ссылки на текущий объект класса и можно обращаться только к статическим членам класса
●Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются)
Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз
В C# применяются следующие модификаторы доступа:
●public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
●private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.
●protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
●internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).
●protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
●private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.
Наиболее простой способ передачи параметров представляет передача по значению, по сути это обычный способ передачи параметров 
При передаче параметров по ссылке перед параметрами используется модификатор ref 
В чем отличие двух способов передачи параметров? При передаче по значению метод получает не саму переменную, а ее копию. А при передаче параметра по ссылке метод получает адрес переменной в памяти. И, таким образом, если в методе изменяется значение параметра, передаваемого по ссылке, то также изменяется и значение переменной, которая передается на его место. 
Разница в том, что out — это выходной параметр, а ref — входно-выходной.
Для ref-параметра вы должны передать его инициализированным, и можете пользоваться его исходным значением. А для out-параметра вы не обязаны инициализировать его перед вызовом функции, не можете использовать его значение в функции до присваивания, и обязаны инициализировать его в функции.
(Таким образом, ref-параметр немного напоминает инициализированную локальную переменную, а out-параметр — неинициализированную.)
Используя ключевое слово params, мы можем передавать неопределенное количество параметров:
1
2
3
4
5
6
7
8
9
10
11
12
static  void  Addition(params int[] integers)
{
    int result = 0;
    for (int i = 0; i < integers.Length; i++)
    {
        result += integers[i];
    }
    Console.WriteLine(result);
}Сам параметр с ключевым словом params при определении метода должен представлять одномерный массив того типа, данные которого мы собираемся использовать. При вызове метода на место параметра с модификатором params мы можем передать как отдельные значения, так и массив значений, либо вообще не передавать параметры.
Ключевое слово unchecked позволяет предотвратить проверку переполнения при выполнении арифметических операций и преобразований с данными целого типа.
Ключевое слово checked используется для явного включения проверки переполнения при выполнении арифметических операций и преобразований с данными целого типа.
По умолчанию выражение, содержащее только константные значения, вызывает ошибку компилятора в том случае, если результат его вычисления выходит за допустимые пределы значений конечного типа. Если выражение содержит одно или несколько неконстантных значений, компилятор не выполняет проверку переполнения.
Ключевое in инициирует передачу аргументов по ссылке. В результате этот формальный параметр становится псевдонимом для аргумента, который должен представлять собой переменную. Другими словами, любая операция в параметре осуществляется с аргументом. Оно аналогично ключевым словам ref и out, за исключением того, что аргументы in не могут быть изменены вызываемым методом. В то время как аргументы ref могут быть изменены, аргументы out должны быть изменены вызывающим объектом, и эти изменения отслеживаются в вызывающем контексте.
Ключевое слово unsafe обозначает небезопасный контекст, необходимый для выполнения любых операций с применением указателей.
Using - предоставляет удобный синтаксис, обеспечивающий правильное использование объектов IDisposable.
Как пишем мы
using (var reader = new StringReader(manyLines))
{
    string? item;
    do {
        item = reader.ReadLine();
        Console.WriteLine(item);
    } while(item != null);
}
Как видит компилятор
{
    var reader = new StringReader(manyLines);
    try {
        string? item;
        do {
            item = reader.ReadLine();
            Console.WriteLine(item);
        } while(item != null);
    } finally
    {
        reader?.Dispose();
    }
}
Предложение where в универсальном определении задает ограничения на типы, которые используются в качестве аргументов для параметров типа в универсальном типе, методе, делегате или локальной функции. Ограничения могут задавать интерфейсы, базовые классы или требовать, чтобы универсальный тип был ссылочным типом, типом значения или неуправляемым типом. Они объявляют характеристики, которыми должен обладать аргумент типа.
Yield - https://metanit.com/sharp/tutorial/4.12.php
Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться сетевое подключение. такие ситуации называются исключениями.
При использовании блока try...catch..finally вначале выполняются все инструкции в блоке try. Если в этом блоке не возникло исключений, то после его выполнения начинает выполняться блок finally. И затем конструкция try..catch..finally завершает свою работу.
Если же в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается, и среда CLR начинает искать блок catch, который может обработать данное исключение. Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок finally.
Если нужный блок catch не найден, то при возникновении исключения программа аварийно завершает свое выполнение.
Все определяемые классы и структуры, как правило, не существуют сами по себе, а заключаются в специальные контейнеры - пространства имен. Пространство имен определяется с помощью ключевого слова namespace, после которого идет название.
Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет использоваться для всех объектов данного класса. Далее идет название возвращаемого типа. Возвращаемый тип представляет тот тип, объекты которого мы хотим получить. К примеру, в результате сложения двух объектов Counter мы ожидаем получить новый объект Counter. А в результате сравнения двух мы хотим получить объект типа bool, который указывает истинно ли условное выражение или ложно. Но в зависимости от задачи возвращаемые типы могут быть любыми.
Затем вместо названия метода идет ключевое слово operator и собственно сам оператор. И далее в скобках перечисляются параметры. Бинарные операторы принимают два параметра, унарные - один параметр. И в любом случае один из параметров должен представлять тот тип - класс или структуру, в котором определяется оператор.
Также переопределены две операции сравнения. Если мы переопределяем одну из этих операций сравнения, то мы также должны переопределить вторую из этих операций. Сами операторы сравнения сравнивают значения свойств Value и в зависимости от результата сравнения возвращают либо true, либо false. 





Индексаторы позволяют индексировать объекты и обращаться к данным по индексу. Фактически с помощью индексаторов мы можем работать с объектами как с массивами. По форме они напоминают свойства со стандартными блоками get и set, которые возвращают и присваивают значение.
Формальное определение индексатора:
1
2
3
4
5возвращаемый_тип this [Тип параметр1, ...]
{
    get { ... }
    set { ... }
}
		Применение нескольких параметров
Также индексатор может принимать несколько параметров. Допустим, у нас есть класс, в котором хранилище определено в виде двухмерного массива или матрицы
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15class Matrix
{
    private int[,] numbers = new int[,] { { 1, 2, 4}, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get
        {
            return numbers[i,j];
        }
        set
        {
            numbers[i, j] = value;
        }
    }
}Теперь для определения индексатора используются два индекса - i и j. И в программе мы уже должны обращаться к объекту, используя два индекса:
1
2
3
4Matrix matrix = new Matrix();
Console.WriteLine(matrix[0, 0]);
matrix[0, 0] = 111;
Console.WriteLine(matrix[0, 0]);Следует учитывать, что индексатор не может быть статическим и применяется только к экземпляру класса. Но при этом индексаторы могут быть виртуальными и абстрактными и могут переопределяться в произодных классах.
  	Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. 
Ключевое слово base
Теперь добавим в наши классы конструкторы:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25class Person
{
    public string Name { get;  set; }
 
    public Person(string name)
    {
        Name = name;
    }
 
    public void Display()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
 
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
}Класс Person имеет конструктор, который устанавливает свойство Name. Поскольку класс Employee наследует и устанавливает то же свойство Name, то логично было бы не писать по сто раз код установки, а как-то вызвать соответствующий код класса Person. К тому же свойств, которые надо установить в конструкторе базового класса, и параметров может быть гораздо больше.
С помощью ключевого слова base мы можем обратиться к базовому классу. В нашем случае в конструкторе класса Employee нам надо установить имя и компанию. Но имя мы передаем на установку в конструктор базового класса, то есть в конструктор класса Person, с помощью выражения base(name).
1
2
3
4
5
6
7
8static void Main(string[] args)
{
    Person p = new Person("Bill");
    p.Display();
    Employee emp = new Employee ("Tom", "Microsoft");
    emp.Display();
    Console.Read();
}Конструкторы в производных классах
Конструкторы не передаются производному классу при наследовании. И если в базовом классе не определен конструктор по умолчанию без параметров, а только конструкторы с параметрами (как в случае с базовым классом Person), то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base. Например, из класса Employee уберем определение конструктора:
1
2
3
4class Employee : Person
{
    public string Company { get; set; }
}В данном случае мы получим ошибку, так как класс Employee не соответствует классу Person, а именно не вызывает конструктор базового класса. Даже если бы мы добавили какой-нибудь конструктор, который бы устанавливал все те же свойства, то мы все равно бы получили ошибку:
1
2
3
4
5public Employee(string name, string company)
{
    Name = name;
    Company = company;
}То есть в классе Employee через ключевое слово base надо явным образом вызвать конструктор класса Person:
1
2
3
4
5public Employee(string name, string company)
        : base(name)
{
    Company = company;
}Либо в качестве альтернативы мы могли бы определить в базовом классе конструктор без параметров:
1
2
3
4
5
6
7
8
9
10class Person
{
    // остальной код класса
    // конструктор по умолчанию
    public Person()
    {
        FirstName = "Tom";
        Console.WriteLine("Вызов конструктора без параметров");
    }
}Тогда в любом конструкторе производного класса, где нет обращения конструктору базового класса, все равно неявно вызывался бы этот конструктор по умолчанию. Например, следующий конструктор
1
2
3
4public Employee(string company)
{
    Company = company;
}Фактически был бы эквивалентен следующему конструктору:
1
2
3
4
5public Employee(string company)
    :base()
{
    Company = company;
}Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.
Определение интерфейса
Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы. 
Для определения интерфейса используется ключевое слово interface. Как правило, названия интерфейсов в C# начинаются с заглавной буквы I, например, IComparable, IEnumerable (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования.
Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности:
Методы
Свойства
Индексаторы
События
Статические поля и константы (начиная с версии C# 8.0)
Однако интерфейсы не могут определять нестатические переменные. 
Еще один момент в объявлении интерфейса: если его члены - методы и свойства не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Это касается также и констант и статических переменных, которые в классах и структурах по умолчанию имееют модификатор private. В интерфейсах же они имеют по умолчанию модификатор public. 
Как и классы, интерфейсы по умолчанию имеют уровень доступа internal, то есть такой интерфейс доступен только в рамках текущего проекта. 
public class List<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IList 

Кроме примитивных типов данных в C# есть такой тип как enum или перечисление. Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum. Далее идет название перечисления, после которого указывается тип перечисления - он обязательно должен представлять целочисленный тип (byte, int, short, long). Если тип явным образом не указан, то по умолчанию используется тип int. 
В С# структура — это группа связанных данных. 
Программисты часто используют структуры для группировки связанных данных с целью передачи их по значению в другую функцию. Намного удобнее поместить все связанные данные в одну переменную и передавать ее, чем несколько различных аргументов. 
Пример сруктуры в которой можно хранить ширину и высоту прямоугольника: 
		public struct rect     // Описание структуры данных
		{
			public int w;  // Поле структуры (ширина прямоугольника)
			public int h;  // Поле структуры (высота прямоугольника)
		}
	
Для инициализации структуры используется оператор new. Однако доступ к структуре возможен до вызова оператора new если всем полям структуры было присвоено первоначальное значение. Структура инициализируется сразу после своего объявления, а все поля устанавливаются в значение по умолчанию (0). Отметим, что компилятор не позволит копировать одну структуру в другую до ее инициализации с помощью ключевого слова new или прочитать значения полей до их установки. 
Пример объявления и инициализации структуры: 
		rect r1 = new rect(); // Объявление структуры
		r1.w = 25;            // Инициализация поля w
		r1.h = 35;            // Инициализация поля h
	
При необходимости скопировать значения из одной структуры в другую все, что нужно сделать, это поставить знак равенства между именами структур: 
		rect r1 = new rect(); // Объявление структуры r1
		rect r2 = new rect(); // Объявление структуры r2
		r1.w = 25;            // Инициализация поля w
		r1.h = 35;            // Инициализация поля h
		r2 = r1;              // Всем полям структуры r2 присваиваются значения полей структуры r1 
	
Пример демонстрирующий применение структур: 
		using System;

		class SampleStruct
		{
			public struct rect
			{
				public int w;
				public int h;
			}

			public static void Main()
			{	
				long s;
				
				rect r1 = new rect();
				rect r2 = new rect();		
				
				r1.w = 25;
				r1.h = 35;
				
				r2 = r1;
				r2.w += 10;
				r2.h += 10;
				
				s = r1.w * r1.h + r2.w * r2.h;
				
				Console.WriteLine("Суммарная площадь прямоугольников: " + s);
				Console.ReadLine();
			}
		}
Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.
1Определение делегатов
Для объявления делегата используется ключевое слово delegate, после которого идет возвращаемый тип, название и параметры. Например:
1delegate void Message();Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.
Применение делегатов
 https://metanit.com/sharp/tutorial/3.43.php
https://tproger.ru/translations/dotnet-delegates/
События
https://professorweb.ru/my/csharp/charp_theory/level10/10_7.php
https://habr.com/ru/company/otus/blog/472094/

С делегатами тесно связаны анонимные методы. Анонимные методы используются для создания экземпляров делегатов.
Определение анонимных методов начинается с ключевого слова delegate, после которого идет в скобках список параметров и тело метода в фигурных скобках:
1
2
3
4delegate(параметры)
{
    // инструкции
}Например:
1
2
3
4
5
6
7
8
9
10
11
12
13
14class Program
{
    delegate void MessageHandler(string message);
    static void Main(string[] args)
    {
        MessageHandler handler = delegate(string mes)
        {
            Console.WriteLine(mes);
        };
        handler("hello world!");
 
        Console.Read();
    }
}Анонимный метод не может существовать сам по себе, он используется для инициализации экземпляра делегата, как в данном случае переменная handler представляет анонимный метод. И через эту переменную делегата можно вызвать данный анонимный метод.
Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.
Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список параметров, а справа блок выражений, использующий эти параметры: (список_параметров) => выражение. Например:
1
2
3
4
5
6
7
8
9
10
11class Program
{
    delegate int Operation(int x, int y);
    static void Main(string[] args)
    {
        Operation operation = (x, y) => x + y;
        Console.WriteLine(operation(10, 20));       // 30
        Console.WriteLine(operation(40, 20));       // 60
        Console.Read();
    }
}https://itvdn.com/ru/blog/article/closing-in-csharp — замыкание
коллекции - https://professorweb.ru/my/csharp/charp_theory/level11/11_1.php
обобщения - https://professorweb.ru/my/csharp/charp_theory/level11/11_1.php
Итераторы (enumerators). Синтаксис, назначение итераторов. Отличие итератора и энумератора. - ???
Про сборку мусора в презентации





